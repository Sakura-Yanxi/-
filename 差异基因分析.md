# 转录组测序数据获取与差异分析（PSA,GO,KEGG,GSEA,GSEA)
## 本次实验主要基于GEO数据库上面的GSE267442样本。主要下载了Series Matrix File(s)和GSE267442_all-TPM.txt.gz[点击直达](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi)。按照矩阵信息进行相应的分组进行了两次映射。由于所下载的TPM中有18列而只有16个样本最终选择映射，完后删除其余的列。共需要 GEO.txt（即TPM文件）、column.txt和notes.txt、[h.all.v2025.1.Hs.symbols.gmt](h.all.v2025.1.Hs.symbols.gmt)（下载Gene Symbols）
## 一、数据准备
### 基于此进行第一次列名映射 column文件
```txt
old	new
428258_N	GSM8266835
428258_T	GSM8266836
429752_N	GSM8266837
429752_T	GSM8266838
430223_N	GSM8266839
430223_T	GSM8266840
430299_N	GSM8266841
430299_T	GSM8266842
431003_N	GSM8266843
431003_T	GSM8266844
440601_N	GSM8266845
440601_T	GSM8266846
440634_N	GSM8266847
440634_T	GSM8266848
440796_N	GSM8266849
440796_T	GSM8266850
```
### 基于此进行第二次列名映射 notes文件
```txt
Gene_Names	Group_Names
GSM8266835	control
GSM8266849	control
GSM8266847	control
GSM8266845	control
GSM8266843	control
GSM8266841	control
GSM8266839	control
GSM8266837	control
GSM8266850	treat
GSM8266848	treat
GSM8266846	treat
GSM8266844	treat
GSM8266842	treat
GSM8266840	treat
GSM8266838	treat
GSM8266836	treat
```
### 二、数据处理
```r
# 设置相应的文件目录
setwd('D:\\r\\class\\GSE267442')
# 读取本地的文件
expr_mat<- read.table("GEO.txt",
                      header = TRUE,        # 第一行是列名
                      sep = "\t",           # 制表符分隔
                      stringsAsFactors = FALSE, # 字符列不作为因子
                      na.strings = "NA",    # 定义缺失值表示
                      row.names = 1,        # 第一列作为行名
                      check.names = FALSE)  # 保持列名原样
# 观察数据维度
dim(expr_mat)
# 映射方法
name_mapping <- read.delim("column.txt", 
                           header = TRUE,  # 如果没有表头为False
                           stringsAsFactors = FALSE) # 字符列不作为因子
# 做表头的映射
mapping_vec <- setNames(name_mapping$new, name_mapping$old)# 类似于py中np.Series一维数组
# print(mapping_vec)
colnames(expr_mat) <- mapping_vec[colnames(expr_mat)]
# 删除多余的列(GEO数据库中表示只有16组但是下载的矩阵中有18组需要删除表头映射不成功的)
expr_mat[,c(1,4)]<- NULL
dim(expr_mat)
# 观察前3行
head(expr_mat,n=3)
# 读取分组方法
notes <- read.delim("notes.txt", 
                     header = TRUE,  # 如果没有表头为False
                     stringsAsFactors = FALSE) # 字符列不作为因子
# 将 'Group' 列转换为因子类型。（按照因子分组）
group_info <- factor(notes$Group_Names)
# 调整列顺序。要与分组顺序一致
expr_mat <- expr_mat[, notes$Gene_Names]

# 数据标准化
library(limma)
# 因我这个是TPM数据，所以不需要使用edgeR的DGEList，直接使用limma的voom方法，但需要稍作调整
# 过滤低表达基因 - 针对TPM数据的适当过滤标准
keep <- rowSums(expr_mat > 0.5) >= 8  # TPM通常使用较低的表达阈值，比如0.5或1，里设定为至少在8个样本中TPM > 0.5
expr_mat_filtered <- expr_mat[keep, ]
# 创建设计矩阵
design <- model.matrix(~ 0 + group_info) # voom原本是为计数数据设计的，但对于TPM数据也能提供有用的转换
colnames(design) <- levels(group_info)
# 对TPM数据使用voom转换
# 特别是当数据呈现异方差性时
v <- voom(expr_mat_filtered, design, plot = TRUE, normalize = "quantile")
expr_data_normalized <- v$E
# 如果你想要更保守的方法，也可以考虑直接使用log2转换的TPM，因为TPM已经是标准化后的数据
# expr_data_normalized <- log2(expr_mat_filtered + 0.1)  # 加一个小值避免log(0)
# 查看标准化后的数据
dim(expr_data_normalized)
head(expr_data_normalized, n=3)
```
### 三、PCA（主成分分析）
```r
#----------------------------------------------------------------#
# 附：PCA (主成分分析)
#----------------------------------------------------------------#
# 加载画图包 (如果前面已加载，可省略)
library(ggplot2)
library(ggrepel)

# 数据准备
# 这里使用 voom 标准化后的数据: expr_data_normalized
# prcomp需要 样本在行, 基因在列, 因此我们需要转置 t()
pca_results <- prcomp(t(expr_data_normalized), scale. = TRUE)
# 提取PCA的坐标 (PC1, PC2等)
pca_data <- as.data.frame(pca_results$x)
# 数据处理时已经完成了列名顺序的排序 因此 t(expr_data_normalized) 的行顺序 和 notes 的行顺序也是一致的
all(rownames(pca_data) == notes$Gene_Names) # 这一步应该是 TRUE
pca_data_with_groups <- cbind(pca_data, notes)
#计算每个主成分的方差贡献度
pca_summary <- summary(pca_results)
percent_variance <- pca_summary$importance["Proportion of Variance", ] * 100
# 画图准备
# 在 aes() 中同时映射 color 和 fill
pca_plot_with_ellipses <- ggplot(
  pca_data_with_groups, 
  aes(x = PC1, y = PC2, color = Group_Names, fill = Group_Names) # 同时映射颜色和填充
) +  # + 是图层叠加运算符
  
# 绘制样本点 (大小不变)
geom_point(size = 3, alpha = 0.8) +
# 添加 95% 置信椭圆
stat_ellipse(
  geom = "polygon",    # 将椭圆绘制为“多边形”
  level = 0.95,        # 设置置信水平为95%
  alpha = 0.1          # 设置填充的透明度为10%，这样不会遮住点
) +
# 添加样本标签
geom_text_repel(aes(label = Gene_Names), 
                max.overlaps = 5,
                size = 3) + 
# 设置标题和坐标轴标签
labs(
  title = "PCA 分析",
  x = paste0("PC1: ", round(percent_variance["PC1"], 1), "% variance"),
  y = paste0("PC2: ", round(percent_variance["PC2"], 1), "% variance"),
  color = "实验分组", # 图例标题
  fill = "实验分组"  # 填充的图例标题
) +
# 美化主题
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) # 标题居中
# 显示新图
print(pca_plot_with_ellipses)
# 2. 将新图保存到本地
ggsave(
  "pca_plot_with_ellipses.tiff",
  plot = pca_plot_with_ellipses,
  width = 8,
  height = 6,
  dpi = 300,
  device = "tiff" # tiff图片色彩更清晰 (可以是 .pdf, .jpeg, .tiff 等)
)
print("PCA分析图片已保存为 pca_plot_with_ellipses.tiff")
```
### 四、将基因ID进行相应的转换 (将Ensembl ID转换为基因符号)
```r
# 加载人类基因注释数据库
library(org.Hs.eg.db)
# 从行名中提取Ensembl ID
ensembl_ids <- rownames(expr_data_normalized)
# 使用 mapIds 函数进行ID转换
gene_symbols <- mapIds(org.Hs.eg.db,
                       keys = ensembl_ids,
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first") # 如果一个ID对应多个符号，只取第一个
# 将基因符号信息添加到我们的voom对象中，方便后续调用
v$genes <- data.frame(symbol = gene_symbols)
```
### 五、使用 limma 进行差异表达分析
```r
# 对每个基因拟合线性模型
fit <- lmFit(v, design)
# 创建对比矩阵，指定想要进行的比较，即 "treat" 组 vs "control" 组
contrast_matrix <- makeContrasts(treat_vs_control = treat - control,
                                 levels = design)
# 将这个对比应用于我们拟合好的模型
fit2 <- contrasts.fit(fit, contrast_matrix)
# 使用经验贝叶斯方法计算最终的统计量（如 t-statistic, p-value, logFC）,这可以提高在小样本情况下分析的稳定性和可靠性
fit2 <- eBayes(fit2)
# 提取最终的差异基因分析结果表，按p值排序,其中number = Inf表示我们想要获取所有基因的结果
top_genes <- topTable(fit2, adjust.method = "fdr", number = Inf)
# 查看排名最靠前的几个差异基因的结果
print("差异分析结果预览:")
head(top_genes,n=3)
```
### 六、结果可视化（火山图，热图）
```r
# 加载画图所需的包
library(ggplot2)
library(ggrepel)
library(pheatmap)

# 绘制火山图 
volcano_data <- top_genes

# 将行名（Ensembl ID）对应的基因名称添加为新的一列
volcano_data$gene <- top_genes$symbol

# 根据阈值（adj.P.Val < 0.05 和 |logFC| > 1）添加显著性分类
volcano_data$Significance <- "Not Significant"
volcano_data$Significance[volcano_data$logFC > 1 & volcano_data$adj.P.Val < 0.05] <- "Up"
volcano_data$Significance[volcano_data$logFC < -1 & volcano_data$adj.P.Val < 0.05] <- "Down"

# 火山图绘制图片
volcano_plot <- ggplot(volcano_data, aes(x = logFC, y = -log10(adj.P.Val), color = Significance)) +
geom_point(alpha = 0.6, size = 1.5) +
scale_color_manual(values = c("Up" = "red", "Down" = "blue", "Not Significant" = "grey")) +

# 对差异最显著的一些基因（例如 adj.P.Val < 0.01 且 |logFC| > 1.5）进行标注
geom_text_repel(data = subset(volcano_data, adj.P.Val < 0.01 & abs(logFC) > 1.5),
                aes(label = gene),
                size = 2,
                max.overlaps = 30) + # 增加 max.overlaps 防止标签重叠
theme_minimal() + # 将图片设置为简介模式
labs(title = "火山图: Treat vs Control",
     x = "Log2 Fold Change (倍数变化)",
     y = "-Log10 Adjusted P-value (调整后P值)") +
theme(plot.title = element_text(hjust = 0.5))
print(volcano_plot)

# 保存在本地
ggsave(
  "volcano_plot_TPM.tiff",       # 文件名和格式 
  plot = volcano_plot,      #  要保存的图形对象
  width = 8,                #  图像宽度 
  height = 6,               #  图像高度 
  dpi = 300                 #  图像分辨率,一般为300
)

# 绘制热图 
# 提取前50个最显著的差异基因用于画图
sig_genes <- topTable(fit2, number = 50)
sig_gene_ids <- rownames(sig_genes)
sig_gene_names <- sig_genes$symbol # 使用基因符号作为行名

# 获取这些基因的标准化表达数据
sig_expr_data <- expr_data_normalized[sig_gene_ids, ]
# 将行名设置为更易读的基因符号
rownames(sig_expr_data) <- sig_gene_names 

# 为热图的列 创建分组注释信息
annotation_col = data.frame(Group = notes$Group_Names)
rownames(annotation_col) = notes$Gene_Names
tiff(
  "heatmap_top50_TPM.tiff",    # 文件名与图片格式
  width = 8,              # 图片宽度
  height = 10,            # 图片高度
  units = "in",           # 尺寸单位:英寸
  res = 300               # 分辨率
)
pheatmap(sig_expr_data,
         cluster_rows = TRUE,         # 对行（基因）进行聚类
         cluster_cols = TRUE,         # 对列（样本）进行聚类
         show_rownames = TRUE,        # 显示基因名
         show_colnames = FALSE,       # 不显示样本名
         scale = "row",               # 对每一行（基因）的数据进行标准化
         annotation_col = annotation_col, # 添加样本分组的注释
         main = "前50个差异表达基因热图")

# 关闭文件设备，完成图片保存
dev.off()
```
### 七、GO与KEGG分析
```r
# 导包
library(clusterProfiler)
library(ggplot2)

# 准备基因列表，筛选出显著上调和下调的基因(设定阈值为：调整后p值 < 0.05 并且 logFC的绝对值 > 1)
diff_genes <- subset(top_genes, adj.P.Val < 0.05 & abs(logFC) > 1)

# 提取这些差异基因的 Entrez ID(clusterProfiler 主要使用 Entrez ID 进行分析)，因此需要将之前获得的基因名称转换为Entrez ID
gene_ids_to_convert <- diff_genes$symbol

# 使用 bitr 函数进行转换
entrez_ids <- bitr(
  gene_ids_to_convert,
  fromType = "SYMBOL",    # 输入基因符号
  toType = "ENTREZID",    # 转换为Entrez ID
  OrgDb = org.Hs.eg.db    # 使用人类基因注释数据库
)

# GO 富集分析 
print("正在进行 GO 富集分析...")
go_result <- enrichGO(
  gene = entrez_ids$ENTREZID, # 提供Entrez ID列表
  OrgDb = org.Hs.eg.db,
  ont = "ALL",              # "ALL" 代表分析 BP, CC, MF 三个方面
  pAdjustMethod = "BH",     # p值校正方法
  qvalueCutoff = 0.05,      # q值阈值
  readable = TRUE           # 再将Entrez ID转换回基因名称，方便阅读
)

# GO富集分析气泡图
go_dot_plot <- dotplot(go_result, showCategory = 15, split = "ONTOLOGY") + 
  facet_grid(ONTOLOGY~., scale="free") +
  ggtitle("GO 富集分析气泡图")+
theme(plot.title = element_text(hjust = 0.5))
print(go_dot_plot)

# 保存GO气泡图
ggsave(
  "go_enrichment_dotplot.tiff",
  plot = go_dot_plot,
  width = 10,
  height = 15,
  dpi = 300,
  device = "tiff" 
)

#  KEGG 通路富集分析 ---
print("正在进行 KEGG 富集分析")
options(timeout = 300) # 由于KEGG 数据库在日本 连接时容易网络超时 因此延长超时时间，防止网络下载失败
kegg_result <- enrichKEGG(
  gene = entrez_ids$ENTREZID,
  organism = "hsa",         # "hsa" 代表人类
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.05
)
# 可视化KEGG富集分析结果
print("正在绘制KEGG富集分析条形图...")
kegg_barplot <- barplot(kegg_result, showCategory = 20) + 
  ggtitle("KEGG 通路富集分析")+
theme(plot.title = element_text(hjust = 0.5))
print(kegg_barplot)

# 保存KEGG条形图
ggsave(
  "kegg_enrichment_barplot.tiff",
  plot = kegg_barplot, 
  width = 10, 
  height = 10, 
  dpi = 300,
  device = "tiff" 
)
```
### 八、GSEA (基因集富集分析)
```r
print("正在准备 GSEA 分析...")
# 准备GSEA的输入数据,GSEA需要一个按logFC降序排列的、以【Entrez ID】为名字的向量，(top_genes 必须是 topTable(fit2, number = Inf) 的完整结果)

# 1. 提取所有基因的 logFC 和基因符号
gsea_data <- top_genes[, c("symbol", "logFC")]

# 2. 将基因符号(SYMBOL) 转换为 Entrez ID
entrez_map <- bitr(gsea_data$symbol, 
                   fromType = "SYMBOL", 
                   toType = "ENTREZID", 
                   OrgDb = org.Hs.eg.db)

# 3. 合并Entrez ID到的本地数据中
gsea_data <- merge(gsea_data, entrez_map, by.x = "symbol", by.y = "SYMBOL")

# 4. 处理重复的Entrez ID：取logFC绝对值最大的那个
gsea_data <- gsea_data[order(gsea_data$logFC, decreasing = TRUE), ]
gsea_data <- gsea_data[!duplicated(gsea_data$ENTREZID), ]

# 5. 创建最终的 GSEA 基因列表 (一个命名的向量)
gsea_gene_list <- gsea_data$logFC
names(gsea_gene_list) <- gsea_data$ENTREZID

# 6. 按logFC值降序排列
gsea_gene_list <- sort(gsea_gene_list, decreasing = TRUE)

# 进行 GSEA-KEGG 分析 
print("正在进行 GSEA-KEGG 分析.") # 可能需要几分钟
gsea_kegg <- gseKEGG(
  geneList = gsea_gene_list,
  organism = "hsa",
  pvalueCutoff = 0.05,
  verbose = FALSE
)

# 绘制GSEA 气泡图
gsea_dot_plot <- dotplot(gsea_kegg, showCategory = 15) + 
  ggtitle("GSEA-KEGG 气泡图")+
theme(plot.title = element_text(hjust = 0.5))
print(gsea_dot_plot)

# GSEA 经典富集图 (以第一个富集通路为例)
gsea_enrich_plot <- gseaplot2(
  gsea_kegg, 
  geneSetID = 1, # 查看富集结果中的第一个通路
  title = gsea_kegg@result$Description[1]
)
print(gsea_enrich_plot)

# 保存GSEA图
ggsave("gsea_kegg_dotplot.tiff", plot = gsea_dot_plot, width = 10, height = 8, dpi = 300, device = "tiff")
ggsave("gsea_kegg_enrichplot.tiff", plot = gsea_enrich_plot, width = 8, height = 6, dpi = 300, device = "tiff")
```
### 九、GSVA (基因集变异分析)
```r
library(GSVA)
library(msigdbr) # 用于从MSigDB数据库获取权威的基因集，但是由于该数据库的服务器在国外，本次即使科学上网也无法通过Rstudio链接上只能本地下载读取了。
# 放在GSE267442的那个文件夹内，便于本地读取
local_gmt_path <- "D:/r/class/GSE267442/h.all.v2025.1.Hs.symbols.gmt"

# 读取 .gmt 文件。read.gmt 会读取文件并返回一个数据框，包含两列：'term' (通路名) 和 'gene' (基因名)
msigdb_gmt_df <- read.gmt(local_gmt_path)
# 观察是否读取成功
head(msigdb_gmt_df)

# GSVA 需要一个列表，其中每个元素的名称是通路名 (term)，内容是该通路包含的基因 (gene)，因此需要将数据框转换为 GSVA 需要的 list 格式
# 本次使用 split 函数来完成这个转换
gs_list <- split(x = msigdb_gmt_df$gene, f = msigdb_gmt_df$term)

# 查看一下转换后的列表结构
str(gs_list, max.level = 1)

# 准备GSVA的表达矩阵，进行GSVA富集分析
gsva_expr_matrix <- v$E
gene_symbols_gsva <- v$genes$symbol
valid_genes_mask <- !is.na(gene_symbols_gsva)
gsva_expr_matrix <- gsva_expr_matrix[valid_genes_mask, ]
rownames(gsva_expr_matrix) <- gene_symbols_gsva[valid_genes_mask]
gsva_expr_matrix <- avereps(gsva_expr_matrix)

# 计算GSVA得分
# 创建一个 GSVA 参数对象，我们把表达矩阵、基因集列表和方法都放进这个对象里
gsva_param_obj <- gsvaParam(
  exprData = gsva_expr_matrix,  # 上述准备的表达矩阵
  geneSets = gs_list,           # 上述准备的基因集列表            
  # kcdf = "Gaussian"          # 因为 voom 已经log转换, "Gaussian"是合适的默认值.
)

# 将这个参数对象传递给 gsva 函数,计算GSVA得分
gsva_scores <- gsva(
  param = gsva_param_obj,  # 将参数对象作为第一个参数
  verbose = TRUE           # 显示进度
)

# 进行差异分析和热图绘制
print("正在对GSVA通路得分进行差异分析...")
fit_gsva <- lmFit(gsva_scores, design)
fit2_gsva <- contrasts.fit(fit_gsva, contrast_matrix)
fit2_gsva <- eBayes(fit2_gsva)
top_pathways <- topTable(fit2_gsva, number = Inf)

print("差异最显著的通路 (基于GSVA得分):")
head(top_pathways)

# 绘制GSVA 可视化热图
sig_pathways_gsva <- subset(top_pathways, adj.P.Val < 0.05)
# 观察是否有显著通路
if (nrow(sig_pathways_gsva) > 0) {
  print(paste("共发现", nrow(sig_pathways_gsva), "个显著差异的通路，正在绘制热图..."))}
# 若大于0 则可执行以下代码

# 从 GSVA 分析得到的通路评分矩阵中，筛选出 “显著差异通路” 对应的评分数据
sig_pathway_scores <- gsva_scores[rownames(sig_pathways_gsva), ] 

# 准备保存热图
tiff(
  "gsva_heatmap_gmt.tiff",  
  width = 8,
  height = 10,
  units = "in",
  res = 300
)
# 绘制热图
pheatmap(
  sig_pathway_scores,
  scale = "row",
  show_colnames = FALSE,
  show_rownames = TRUE,
  cluster_cols = TRUE,
  annotation_col = annotation_col,
  main = "GSVA 显著差异通路热图"
)
# 关闭并保存
dev.off()
``` 
